Cody AdamsAlgorithms PATo run this code in the UNIX terminal, unzip the file submitted. Navigate into the folder MapFolder and use the command “python3 Map.py”.To start, I made a class called Map that initially loads in all of the edges and vertices into python lists. I made a simple class for edges and vertices that makes it easy to access the fields we want for each. After those are loaded in, I have a function, mainProgram, that starts the whole process. This is where the program will ask for the starting location, ending location, whether to minimize by time, and whether they’re using a skateboard. I also use a function, printTraversal, to do all of the heavy output work. In terms of calculating time, I did all of this work in the edge class as I thought that made the most sense. This class already held the distances, so it seemed reasonable to calculate time in the same class.To get the shortest path from one vertex to another, I created a class called ShortestPath. This is where I implemented Dijkstra’s to find the minimum path based off of time or distance. To aid in this process, I created another class called MinHeap. This was just my own implementation of a Minimum Heap where the heap array was filled with tuples that had the data as the first value and the priority as the second. I used this heap in my Dijkstras algorithm instead of the queue that is usually used. I stored the distance used in the algorithm in my Vertex class as a field, dist, and that is what I initially set to infinite to start the algorithm. I then add all of the vertices to the Min Heap and continue extracting the min until it is empty, getting all adjacent edges along the way and keeping track of the distance with the dist field of the vertices on the other end of the adjacent edges. In the end my Dijkstras return the end node to make the backtracking of the edges for printing easier. I got stuck on this part of the PA for an extremely long time due to difficulties with minimizing time. I spent most of my time trying to figure out why the output didn’t match when it ended up being a problem with skateboards not being allowed on places where they should, which was a combination of uppercase detection and converting x surfaces to F.For the next part of the PA, part 2a, I created the class MinimumSpanning. The class inputs were very similar to those of ShortestPath. Prim’s was what I ended up spending the most time on. I implemented two classes, Tree and TreeNode, to actually form the minimum spanning tree. Because I spent so much time on Prim’s, I was not able to implement part 2b of the PA at all. I wanted to start writing the code for it but was worried I wouldn’t have enough time to do my ReadMe, output files, and comments. 